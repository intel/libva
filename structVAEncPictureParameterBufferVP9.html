<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>VA-API: VAEncPictureParameterBufferVP9 Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">VA-API
   &#160;<span id="projectnumber">2.19.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="structVAEncPictureParameterBufferVP9-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">VAEncPictureParameterBufferVP9 Struct Reference<div class="ingroups"><a class="el" href="group__api__enc__vp9.html">VP9 encoding API</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>VP9 Encoding Picture Parameter Buffer Structure.  
 <a href="structVAEncPictureParameterBufferVP9.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="va__enc__vp9_8h_source.html">va_enc_vp9.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ade9a490693e7c685ca0daa923d7913ac"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVAEncPictureParameterBufferVP9.html#ade9a490693e7c685ca0daa923d7913ac">frame_width_src</a></td></tr>
<tr class="separator:ade9a490693e7c685ca0daa923d7913ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5755e9f57004b81516b9da765c9fff0a"><td class="memItemLeft" align="right" valign="top">VASurfaceID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVAEncPictureParameterBufferVP9.html#a5755e9f57004b81516b9da765c9fff0a">reference_frames</a> [8]</td></tr>
<tr class="memdesc:a5755e9f57004b81516b9da765c9fff0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">reference frame buffers Each entry of the array specifies the surface index of the picture that is referred by current picture or will be referred by any future picture. The valid entries take value from 0 to 127, inclusive. Non-valid entries, those do not point to pictures which are referred by current picture or future pictures, should take value 0xFF. Other values are not allowed.  <a href="#a5755e9f57004b81516b9da765c9fff0a">More...</a><br /></td></tr>
<tr class="separator:a5755e9f57004b81516b9da765c9fff0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe1bcc84d9490d48f92323770716c9a2"><td class="memItemLeft" align="right" valign="top"><a id="abe1bcc84d9490d48f92323770716c9a2"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVAEncPictureParameterBufferVP9.html#abe1bcc84d9490d48f92323770716c9a2">refresh_frame_flags</a></td></tr>
<tr class="memdesc:abe1bcc84d9490d48f92323770716c9a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">indicate which frames in DPB should be refreshed. same syntax and semantic as in VP9 code. <br /></td></tr>
<tr class="separator:abe1bcc84d9490d48f92323770716c9a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab045759a26416249a1c7399aed8ca496"><td class="memItemLeft" align="right" valign="top"><a id="ab045759a26416249a1c7399aed8ca496"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVAEncPictureParameterBufferVP9.html#ab045759a26416249a1c7399aed8ca496">luma_ac_qindex</a></td></tr>
<tr class="memdesc:ab045759a26416249a1c7399aed8ca496"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base Q index in the VP9 term. Added with per segment delta Q index to get Q index of Luma AC. <br /></td></tr>
<tr class="separator:ab045759a26416249a1c7399aed8ca496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a108f69df1bc0b7ff947f292f72fc75"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVAEncPictureParameterBufferVP9.html#a7a108f69df1bc0b7ff947f292f72fc75">luma_dc_qindex_delta</a></td></tr>
<tr class="separator:a7a108f69df1bc0b7ff947f292f72fc75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd5e676254bb7d74143bbda84d753a8f"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVAEncPictureParameterBufferVP9.html#afd5e676254bb7d74143bbda84d753a8f">chroma_ac_qindex_delta</a></td></tr>
<tr class="separator:afd5e676254bb7d74143bbda84d753a8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a913dd7e9c4b63677c4f32881cd20773a"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVAEncPictureParameterBufferVP9.html#a913dd7e9c4b63677c4f32881cd20773a">chroma_dc_qindex_delta</a></td></tr>
<tr class="separator:a913dd7e9c4b63677c4f32881cd20773a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f66e58711415e352907dd52bc03db90"><td class="memItemLeft" align="right" valign="top"><a id="a8f66e58711415e352907dd52bc03db90"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVAEncPictureParameterBufferVP9.html#a8f66e58711415e352907dd52bc03db90">filter_level</a></td></tr>
<tr class="memdesc:a8f66e58711415e352907dd52bc03db90"><td class="mdescLeft">&#160;</td><td class="mdescRight">filter level Corresponds to the same VP9 syntax element in frame header. <br /></td></tr>
<tr class="separator:a8f66e58711415e352907dd52bc03db90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f3a63ec592328cef2ccda3139e9f558"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVAEncPictureParameterBufferVP9.html#a2f3a63ec592328cef2ccda3139e9f558">sharpness_level</a></td></tr>
<tr class="separator:a2f3a63ec592328cef2ccda3139e9f558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53cebf50fb2fe3a781fc0e7f05b32830"><td class="memItemLeft" align="right" valign="top"><a id="a53cebf50fb2fe3a781fc0e7f05b32830"></a>
int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVAEncPictureParameterBufferVP9.html#a53cebf50fb2fe3a781fc0e7f05b32830">ref_lf_delta</a> [4]</td></tr>
<tr class="memdesc:a53cebf50fb2fe3a781fc0e7f05b32830"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loop filter level reference delta values. Contains a list of 4 delta values for reference frame based block-level loop filter adjustment. If no update, set to 0. value range [-63..63]. <br /></td></tr>
<tr class="separator:a53cebf50fb2fe3a781fc0e7f05b32830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad91be6d93bc918d60ba63a684b658802"><td class="memItemLeft" align="right" valign="top"><a id="ad91be6d93bc918d60ba63a684b658802"></a>
int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVAEncPictureParameterBufferVP9.html#ad91be6d93bc918d60ba63a684b658802">mode_lf_delta</a> [2]</td></tr>
<tr class="memdesc:ad91be6d93bc918d60ba63a684b658802"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loop filter level mode delta values. Contains a list of 4 delta values for coding mode based MB-level loop filter adjustment. If no update, set to 0. value range [-63..63]. <br /></td></tr>
<tr class="separator:ad91be6d93bc918d60ba63a684b658802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ebd1bce53897920016ad6b6c615c511"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVAEncPictureParameterBufferVP9.html#a5ebd1bce53897920016ad6b6c615c511">bit_offset_ref_lf_delta</a></td></tr>
<tr class="separator:a5ebd1bce53897920016ad6b6c615c511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc8434527066004e64f1a08dd2228312"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVAEncPictureParameterBufferVP9.html#adc8434527066004e64f1a08dd2228312">bit_offset_mode_lf_delta</a></td></tr>
<tr class="separator:adc8434527066004e64f1a08dd2228312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd1aea5bfe9dab9be5c76507a880163b"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVAEncPictureParameterBufferVP9.html#afd1aea5bfe9dab9be5c76507a880163b">bit_offset_lf_level</a></td></tr>
<tr class="separator:afd1aea5bfe9dab9be5c76507a880163b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c2742b2a871e50fb3832380ecfd95a5"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVAEncPictureParameterBufferVP9.html#a5c2742b2a871e50fb3832380ecfd95a5">bit_offset_qindex</a></td></tr>
<tr class="separator:a5c2742b2a871e50fb3832380ecfd95a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d1bceea9a333a8f00e47a3e5346c958"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVAEncPictureParameterBufferVP9.html#a5d1bceea9a333a8f00e47a3e5346c958">bit_offset_first_partition_size</a></td></tr>
<tr class="separator:a5d1bceea9a333a8f00e47a3e5346c958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a01a1d137482ee7a72db54c9cb048ff"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVAEncPictureParameterBufferVP9.html#a7a01a1d137482ee7a72db54c9cb048ff">bit_offset_segmentation</a></td></tr>
<tr class="separator:a7a01a1d137482ee7a72db54c9cb048ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e0bf7e97e0162584ac827b70b4153d6"><td class="memItemLeft" align="right" valign="top"><a id="a9e0bf7e97e0162584ac827b70b4153d6"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVAEncPictureParameterBufferVP9.html#a9e0bf7e97e0162584ac827b70b4153d6">bit_size_segmentation</a></td></tr>
<tr class="memdesc:a9e0bf7e97e0162584ac827b70b4153d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">length in bit of segmentation portion from the location in bit stream where segmentation_enabled syntax is coded. When auto_segmentation is enabled, GPU uses this bit size to locate and update the information after segmentation. <br /></td></tr>
<tr class="separator:a9e0bf7e97e0162584ac827b70b4153d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6919ae19dc954826a83912cdcca96b64"><td class="memItemLeft" align="right" valign="top"><a id="a6919ae19dc954826a83912cdcca96b64"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVAEncPictureParameterBufferVP9.html#a6919ae19dc954826a83912cdcca96b64">log2_tile_rows</a></td></tr>
<tr class="memdesc:a6919ae19dc954826a83912cdcca96b64"><td class="mdescLeft">&#160;</td><td class="mdescRight">log2 of number of tile rows Corresponds to the same VP9 syntax element in frame header. value range [0..2] <br /></td></tr>
<tr class="separator:a6919ae19dc954826a83912cdcca96b64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b99e6af509efe09142c7f3c3548911d"><td class="memItemLeft" align="right" valign="top"><a id="a7b99e6af509efe09142c7f3c3548911d"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVAEncPictureParameterBufferVP9.html#a7b99e6af509efe09142c7f3c3548911d">log2_tile_columns</a></td></tr>
<tr class="memdesc:a7b99e6af509efe09142c7f3c3548911d"><td class="mdescLeft">&#160;</td><td class="mdescRight">log2 of number of tile columns Corresponds to the same VP9 syntax element in frame header. value range [0..6] <br /></td></tr>
<tr class="separator:a7b99e6af509efe09142c7f3c3548911d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa62323de5fa0f917d8db33bcd8a075ff"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVAEncPictureParameterBufferVP9.html#aa62323de5fa0f917d8db33bcd8a075ff">skip_frame_flag</a></td></tr>
<tr class="memdesc:aa62323de5fa0f917d8db33bcd8a075ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">indicate frame-skip happens Application may choose to drop/skip one or mulitple encoded frames or to-be-encoded frame due to various reasons such as insufficient bandwidth. Application uses the following three flags to inform GPU about frame-skip.  <a href="#aa62323de5fa0f917d8db33bcd8a075ff">More...</a><br /></td></tr>
<tr class="separator:aa62323de5fa0f917d8db33bcd8a075ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aece75972e3747d7b68a07df99f96702d"><td class="memItemLeft" align="right" valign="top"><a id="aece75972e3747d7b68a07df99f96702d"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVAEncPictureParameterBufferVP9.html#aece75972e3747d7b68a07df99f96702d">number_skip_frames</a></td></tr>
<tr class="memdesc:aece75972e3747d7b68a07df99f96702d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of frames skipped prior to the current frame. It includes only the skipped frames that were not counted before, and does not include the frame with skip_frame_flag == 2. Valid when skip_frame_flag = 1. <br /></td></tr>
<tr class="separator:aece75972e3747d7b68a07df99f96702d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3148e7b301616869cfb63b9a3f72bb39"><td class="memItemLeft" align="right" valign="top"><a id="a3148e7b301616869cfb63b9a3f72bb39"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVAEncPictureParameterBufferVP9.html#a3148e7b301616869cfb63b9a3f72bb39">skip_frames_size</a></td></tr>
<tr class="memdesc:a3148e7b301616869cfb63b9a3f72bb39"><td class="mdescLeft">&#160;</td><td class="mdescRight">When skip_frame_flag = 1, the size of the skipped frames in bits. It includes only the skipped frames that were not counted before, and does not include the frame size with skip_frame_flag = 2. When skip_frame_flag = 2, it is the size of the current skipped frame that is to be encrypted. <br /></td></tr>
<tr class="separator:a3148e7b301616869cfb63b9a3f72bb39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af616beb2d6602584af4c30a16e8548e4"><td class="memItemLeft" align="right" valign="top"><a id="af616beb2d6602584af4c30a16e8548e4"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVAEncPictureParameterBufferVP9.html#af616beb2d6602584af4c30a16e8548e4">va_reserved</a> [VA_PADDING_MEDIUM]</td></tr>
<tr class="memdesc:af616beb2d6602584af4c30a16e8548e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserved bytes for future use, must be zero. <br /></td></tr>
<tr class="separator:af616beb2d6602584af4c30a16e8548e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada4ced9c239bab566b0d33d175f57020"><td class="memItemLeft" align="right" valign="top"><a id="ada4ced9c239bab566b0d33d175f57020"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVAEncPictureParameterBufferVP9.html#ada4ced9c239bab566b0d33d175f57020">ref_frame_ctrl_l0</a>: 3</td></tr>
<tr class="memdesc:ada4ced9c239bab566b0d33d175f57020"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indiates which frames to be used as reference. (Ref_frame_ctrl &amp; 0x01) ? 1: last frame as reference frame, 0: not. (Ref_frame_ctrl &amp; 0x02) ? 1: golden frame as reference frame, 0: not. (Ref_frame_ctrl &amp; 0x04) ? 1: alt frame as reference frame, 0: not. L0 is for forward prediction. L1 is for backward prediction. <br /></td></tr>
<tr class="separator:ada4ced9c239bab566b0d33d175f57020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a688c7ac722e9a06b24a722f20e724c47"><td class="memItemLeft" align="right" valign="top"><a id="a688c7ac722e9a06b24a722f20e724c47"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVAEncPictureParameterBufferVP9.html#a688c7ac722e9a06b24a722f20e724c47">ref_last_idx</a>: 3</td></tr>
<tr class="memdesc:a688c7ac722e9a06b24a722f20e724c47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Last Reference Frame index Specifies the index to RefFrameList[] which points to the LAST reference frame. It corresponds to active_ref_idx[0] in VP9 code. <br /></td></tr>
<tr class="separator:a688c7ac722e9a06b24a722f20e724c47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ce936d7a1fda9199ef1a672c224f25e"><td class="memItemLeft" align="right" valign="top"><a id="a9ce936d7a1fda9199ef1a672c224f25e"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVAEncPictureParameterBufferVP9.html#a9ce936d7a1fda9199ef1a672c224f25e">ref_last_sign_bias</a>: 1</td></tr>
<tr class="memdesc:a9ce936d7a1fda9199ef1a672c224f25e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the Sign Bias of the LAST reference frame. It corresponds to ref_frame_sign_bias[LAST_FRAME] in VP9 code. <br /></td></tr>
<tr class="separator:a9ce936d7a1fda9199ef1a672c224f25e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08807fb2dc08c55f748c9216859eb201"><td class="memItemLeft" align="right" valign="top"><a id="a08807fb2dc08c55f748c9216859eb201"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVAEncPictureParameterBufferVP9.html#a08807fb2dc08c55f748c9216859eb201">ref_gf_idx</a>: 3</td></tr>
<tr class="memdesc:a08807fb2dc08c55f748c9216859eb201"><td class="mdescLeft">&#160;</td><td class="mdescRight">GOLDEN Reference Frame index Specifies the index to RefFrameList[] which points to the Golden reference frame. It corresponds to active_ref_idx[1] in VP9 code. <br /></td></tr>
<tr class="separator:a08807fb2dc08c55f748c9216859eb201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae33727850bfd025b1fee693408472d09"><td class="memItemLeft" align="right" valign="top"><a id="ae33727850bfd025b1fee693408472d09"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVAEncPictureParameterBufferVP9.html#ae33727850bfd025b1fee693408472d09">ref_gf_sign_bias</a>: 1</td></tr>
<tr class="memdesc:ae33727850bfd025b1fee693408472d09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the Sign Bias of the GOLDEN reference frame. It corresponds to ref_frame_sign_bias[GOLDEN_FRAME] in VP9 code. <br /></td></tr>
<tr class="separator:ae33727850bfd025b1fee693408472d09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada4c62b4ab074dac39cf1670ee316363"><td class="memItemLeft" align="right" valign="top"><a id="ada4c62b4ab074dac39cf1670ee316363"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVAEncPictureParameterBufferVP9.html#ada4c62b4ab074dac39cf1670ee316363">ref_arf_idx</a>: 3</td></tr>
<tr class="memdesc:ada4c62b4ab074dac39cf1670ee316363"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate Reference Frame index Specifies the index to RefFrameList[] which points to the Alternate reference frame. It corresponds to active_ref_idx[2] in VP9 code. <br /></td></tr>
<tr class="separator:ada4c62b4ab074dac39cf1670ee316363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb7504e26f1a215476bbcc69a1b71d8c"><td class="memItemLeft" align="right" valign="top"><a id="aeb7504e26f1a215476bbcc69a1b71d8c"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVAEncPictureParameterBufferVP9.html#aeb7504e26f1a215476bbcc69a1b71d8c">ref_arf_sign_bias</a>: 1</td></tr>
<tr class="memdesc:aeb7504e26f1a215476bbcc69a1b71d8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the Sign Bias of the ALTERNATE reference frame. It corresponds to ref_frame_sign_bias[ALTREF_FRAME] in VP9 code. <br /></td></tr>
<tr class="separator:aeb7504e26f1a215476bbcc69a1b71d8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4c0a109081aa3f4eeebbcc23fe6c601"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVAEncPictureParameterBufferVP9.html#ad4c0a109081aa3f4eeebbcc23fe6c601">frame_type</a>: 1</td></tr>
<tr class="separator:ad4c0a109081aa3f4eeebbcc23fe6c601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad24791a7f1f9e51f05d337f094eacb8e"><td class="memItemLeft" align="right" valign="top"><a id="ad24791a7f1f9e51f05d337f094eacb8e"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVAEncPictureParameterBufferVP9.html#ad24791a7f1f9e51f05d337f094eacb8e">show_frame</a>: 1</td></tr>
<tr class="memdesc:ad24791a7f1f9e51f05d337f094eacb8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">show_frame 0: current frame is not for display 1: current frame is for display <br /></td></tr>
<tr class="separator:ad24791a7f1f9e51f05d337f094eacb8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3e1cc448e99ef3078610a602f8b6b78"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVAEncPictureParameterBufferVP9.html#ae3e1cc448e99ef3078610a602f8b6b78">error_resilient_mode</a>: 1</td></tr>
<tr class="separator:ae3e1cc448e99ef3078610a602f8b6b78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a892424fc096ae8400968cdc0157a1600"><td class="memItemLeft" align="right" valign="top"><a id="a892424fc096ae8400968cdc0157a1600"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVAEncPictureParameterBufferVP9.html#a892424fc096ae8400968cdc0157a1600">intra_only</a>: 1</td></tr>
<tr class="memdesc:a892424fc096ae8400968cdc0157a1600"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicate intra-only for inter pictures. Must be 0 for key frames. 0: inter frame use both intra and inter blocks 1: inter frame use only intra blocks. <br /></td></tr>
<tr class="separator:a892424fc096ae8400968cdc0157a1600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a769768244194a83a7e337b820aac532d"><td class="memItemLeft" align="right" valign="top"><a id="a769768244194a83a7e337b820aac532d"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVAEncPictureParameterBufferVP9.html#a769768244194a83a7e337b820aac532d">allow_high_precision_mv</a>: 1</td></tr>
<tr class="memdesc:a769768244194a83a7e337b820aac532d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicate high precision mode for Motion Vector prediction 0: normal mode 1: high precision mode. <br /></td></tr>
<tr class="separator:a769768244194a83a7e337b820aac532d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af48204d0d50ea64d478e1c51eafcd724"><td class="memItemLeft" align="right" valign="top"><a id="af48204d0d50ea64d478e1c51eafcd724"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVAEncPictureParameterBufferVP9.html#af48204d0d50ea64d478e1c51eafcd724">mcomp_filter_type</a>: 3</td></tr>
<tr class="memdesc:af48204d0d50ea64d478e1c51eafcd724"><td class="mdescLeft">&#160;</td><td class="mdescRight">Motion Compensation Filter type 0: eight-tap (only this mode is supported now.) 1: eight-tap-smooth 2: eight-tap-sharp 3: bilinear 4: switchable. <br /></td></tr>
<tr class="separator:af48204d0d50ea64d478e1c51eafcd724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e70ec72a48b1a62c2076231579ec92d"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVAEncPictureParameterBufferVP9.html#a5e70ec72a48b1a62c2076231579ec92d">lossless_mode</a>: 1</td></tr>
<tr class="memdesc:a5e70ec72a48b1a62c2076231579ec92d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies if the picture is coded in lossless mode.  <a href="#a5e70ec72a48b1a62c2076231579ec92d">More...</a><br /></td></tr>
<tr class="separator:a5e70ec72a48b1a62c2076231579ec92d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a9c1d2cb85d88f550f1a1dfdeca49f1"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVAEncPictureParameterBufferVP9.html#a9a9c1d2cb85d88f550f1a1dfdeca49f1">comp_prediction_mode</a>: 2</td></tr>
<tr class="memdesc:a9a9c1d2cb85d88f550f1a1dfdeca49f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">MV prediction mode. Corresponds to VP9 variable with same name. comp_prediction_mode = 0: single prediction ony, comp_prediction_mode = 1: compound prediction, comp_prediction_mode = 2: hybrid prediction.  <a href="#a9a9c1d2cb85d88f550f1a1dfdeca49f1">More...</a><br /></td></tr>
<tr class="separator:a9a9c1d2cb85d88f550f1a1dfdeca49f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97faa47ee9250572564fe826dd34edce"><td class="memItemLeft" align="right" valign="top"><a id="a97faa47ee9250572564fe826dd34edce"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVAEncPictureParameterBufferVP9.html#a97faa47ee9250572564fe826dd34edce">auto_segmentation</a>: 1</td></tr>
<tr class="memdesc:a97faa47ee9250572564fe826dd34edce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicate how segmentation is specified 0 application specifies segmentation partitioning and relevant parameters. 1 GPU may decide on segmentation. If application already provides segmentation information, GPU may choose to honor it and further split into more levels if possible. <br /></td></tr>
<tr class="separator:a97faa47ee9250572564fe826dd34edce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d6c14d649e95b77d2cad18c2898f8fe"><td class="memItemLeft" align="right" valign="top"><a id="a7d6c14d649e95b77d2cad18c2898f8fe"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVAEncPictureParameterBufferVP9.html#a7d6c14d649e95b77d2cad18c2898f8fe">super_frame_flag</a>: 1</td></tr>
<tr class="memdesc:a7d6c14d649e95b77d2cad18c2898f8fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicate super frame syntax should be inserted 0 current frame is not encapsulated in super frame structure 1 current fame is to be encapsulated in super frame structure. super frame index syntax will be inserted by encoder at the end of current frame. <br /></td></tr>
<tr class="separator:a7d6c14d649e95b77d2cad18c2898f8fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>VP9 Encoding Picture Parameter Buffer Structure. </p>
<p>This structure conveys picture level parameters. </p>
</div><h2 class="groupheader">Member Data Documentation</h2>
<a id="a5d1bceea9a333a8f00e47a3e5346c958"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d1bceea9a333a8f00e47a3e5346c958">&#9670;&nbsp;</a></span>bit_offset_first_partition_size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t VAEncPictureParameterBufferVP9::bit_offset_first_partition_size</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Offset from starting position of output bitstream in bits where First Partition Size should be inserted. </p>

</div>
</div>
<a id="afd1aea5bfe9dab9be5c76507a880163b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd1aea5bfe9dab9be5c76507a880163b">&#9670;&nbsp;</a></span>bit_offset_lf_level</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t VAEncPictureParameterBufferVP9::bit_offset_lf_level</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Offset from starting position of output bitstream in bits where (loop) filter_level should be inserted. </p>

</div>
</div>
<a id="adc8434527066004e64f1a08dd2228312"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc8434527066004e64f1a08dd2228312">&#9670;&nbsp;</a></span>bit_offset_mode_lf_delta</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t VAEncPictureParameterBufferVP9::bit_offset_mode_lf_delta</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Offset from starting position of output bitstream in bits where mode_lf_delta[] should be inserted.</p>
<p>In BRC mode, always insert mode_lf_delta[] (This implies uncompressed header should have mode_ref_delta_enabled=1 and mode_ref_delta_update=1). </p>

</div>
</div>
<a id="a5c2742b2a871e50fb3832380ecfd95a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c2742b2a871e50fb3832380ecfd95a5">&#9670;&nbsp;</a></span>bit_offset_qindex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t VAEncPictureParameterBufferVP9::bit_offset_qindex</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Offset from starting position of output bitstream in bits where Base Qindex should be inserted. </p>

</div>
</div>
<a id="a5ebd1bce53897920016ad6b6c615c511"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ebd1bce53897920016ad6b6c615c511">&#9670;&nbsp;</a></span>bit_offset_ref_lf_delta</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t VAEncPictureParameterBufferVP9::bit_offset_ref_lf_delta</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Offset from starting position of output bitstream in bits where ref_lf_delta[] should be inserted. This offset should cover any metadata ahead of uncompressed header in inserted bit stream buffer (the offset should be same as that for final output bitstream buffer).</p>
<p>In BRC mode, always insert ref_lf_delta[] (This implies uncompressed header should have mode_ref_delta_enabled=1 and mode_ref_delta_update=1). </p>

</div>
</div>
<a id="a7a01a1d137482ee7a72db54c9cb048ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a01a1d137482ee7a72db54c9cb048ff">&#9670;&nbsp;</a></span>bit_offset_segmentation</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t VAEncPictureParameterBufferVP9::bit_offset_segmentation</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Offset from starting position of output bitstream in bits where segmentation_enabled is located in bitstream. When auto_segmentation is enabled, GPU uses this offset to locate and update the segmentation related information. </p>

</div>
</div>
<a id="afd5e676254bb7d74143bbda84d753a8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd5e676254bb7d74143bbda84d753a8f">&#9670;&nbsp;</a></span>chroma_ac_qindex_delta</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t VAEncPictureParameterBufferVP9::chroma_ac_qindex_delta</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Q index delta from base Q index in the VP9 term for Chroma AC. </p>

</div>
</div>
<a id="a913dd7e9c4b63677c4f32881cd20773a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a913dd7e9c4b63677c4f32881cd20773a">&#9670;&nbsp;</a></span>chroma_dc_qindex_delta</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t VAEncPictureParameterBufferVP9::chroma_dc_qindex_delta</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Q index delta from base Q index in the VP9 term for Chroma DC. </p>

</div>
</div>
<a id="a9a9c1d2cb85d88f550f1a1dfdeca49f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a9c1d2cb85d88f550f1a1dfdeca49f1">&#9670;&nbsp;</a></span>comp_prediction_mode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t VAEncPictureParameterBufferVP9::comp_prediction_mode</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>MV prediction mode. Corresponds to VP9 variable with same name. comp_prediction_mode = 0: single prediction ony, comp_prediction_mode = 1: compound prediction, comp_prediction_mode = 2: hybrid prediction. </p>
<p>Not mandatory. App may suggest the setting based on power or performance. Kernal may use it as a guildline and decide the proper setting on its own. </p>

</div>
</div>
<a id="ae3e1cc448e99ef3078610a602f8b6b78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3e1cc448e99ef3078610a602f8b6b78">&#9670;&nbsp;</a></span>error_resilient_mode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t VAEncPictureParameterBufferVP9::error_resilient_mode</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The following fields correspond to the same VP9 syntax elements in the frame header. </p>

</div>
</div>
<a id="ad4c0a109081aa3f4eeebbcc23fe6c601"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4c0a109081aa3f4eeebbcc23fe6c601">&#9670;&nbsp;</a></span>frame_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t VAEncPictureParameterBufferVP9::frame_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates if the current frame is a key frame or not. Corresponds to the same VP9 syntax element in frame tag. </p>

</div>
</div>
<a id="ade9a490693e7c685ca0daa923d7913ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade9a490693e7c685ca0daa923d7913ac">&#9670;&nbsp;</a></span>frame_width_src</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t VAEncPictureParameterBufferVP9::frame_width_src</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VP9 encoder may support dynamic scaling function. If enabled (enable_dynamic_scaling is set), application may request GPU encodes picture with a different resolution from the raw source. GPU should handle the scaling process of source and all reference frames. </p>

</div>
</div>
<a id="a5e70ec72a48b1a62c2076231579ec92d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e70ec72a48b1a62c2076231579ec92d">&#9670;&nbsp;</a></span>lossless_mode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t VAEncPictureParameterBufferVP9::lossless_mode</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies if the picture is coded in lossless mode. </p>
<p>lossless_mode = base_qindex == 0 &amp;&amp; y_dc_delta_q == 0 \ &amp;&amp; uv_dc_delta_q == 0 &amp;&amp; uv_ac_delta_q == 0; Where base_qindex, y_dc_delta_q, uv_dc_delta_q and uv_ac_delta_q are all variables in VP9 code.</p>
<p>When enabled, tx_mode needs to be set to 4x4 only and all tu_size in CU record set to 4x4 for entire frame. Software also has to program such that final_qindex=0 and final_filter_level=0 following the Quant Scale and Filter Level Table in Segmentation State section. Hardware forces Hadamard Tx when this bit is set. When lossless_mode is on, BRC has to be turned off. 0: normal mode 1: lossless mode </p>

</div>
</div>
<a id="a7a108f69df1bc0b7ff947f292f72fc75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a108f69df1bc0b7ff947f292f72fc75">&#9670;&nbsp;</a></span>luma_dc_qindex_delta</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t VAEncPictureParameterBufferVP9::luma_dc_qindex_delta</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Q index delta from base Q index in the VP9 term for Luma DC. </p>

</div>
</div>
<a id="a5755e9f57004b81516b9da765c9fff0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5755e9f57004b81516b9da765c9fff0a">&#9670;&nbsp;</a></span>reference_frames</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VASurfaceID VAEncPictureParameterBufferVP9::reference_frames[8]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>reference frame buffers Each entry of the array specifies the surface index of the picture that is referred by current picture or will be referred by any future picture. The valid entries take value from 0 to 127, inclusive. Non-valid entries, those do not point to pictures which are referred by current picture or future pictures, should take value 0xFF. Other values are not allowed. </p>
<p>Application should update this array based on the refreshing information expected. </p>

</div>
</div>
<a id="a2f3a63ec592328cef2ccda3139e9f558"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f3a63ec592328cef2ccda3139e9f558">&#9670;&nbsp;</a></span>sharpness_level</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t VAEncPictureParameterBufferVP9::sharpness_level</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Controls the deblocking filter sensitivity. Corresponds to the same VP9 syntax element in frame header. </p>

</div>
</div>
<a id="aa62323de5fa0f917d8db33bcd8a075ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa62323de5fa0f917d8db33bcd8a075ff">&#9670;&nbsp;</a></span>skip_frame_flag</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t VAEncPictureParameterBufferVP9::skip_frame_flag</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>indicate frame-skip happens Application may choose to drop/skip one or mulitple encoded frames or to-be-encoded frame due to various reasons such as insufficient bandwidth. Application uses the following three flags to inform GPU about frame-skip. </p>
<p>value range of skip_frame_flag: [0..2] 0 - encode as normal, no skip; 1 - one or more frames were skipped by application prior to the current frame. Encode the current frame as normal. The driver will pass the number_skip_frames and skip_frames_size to bit rate control for adjustment. 2 - the current frame is to be skipped. Do not encode it but encrypt the packed header contents. This is for the secure encoding case where application generates a frame of all skipped blocks. The packed header will contain the skipped frame. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="va__enc__vp9_8h_source.html">va_enc_vp9.h</a></li>
</ul>
</div><!-- contents -->
<hr class="footer"/><address class="footer"><small>
Generated for VA-API by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13</small></address>
</body>
</html>
