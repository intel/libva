<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>VA-API: VAProcPipelineParameterBuffer Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">VA-API
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="structVAProcPipelineParameterBuffer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">VAProcPipelineParameterBuffer Struct Reference<div class="ingroups"><a class="el" href="group__api__vpp.html">Video processing API</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Video processing pipeline configuration.  
 <a href="structVAProcPipelineParameterBuffer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="va__vpp_8h_source.html">va_vpp.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a9a60820f23d4b34e4b9b3ef63c6e56d4"><td class="memItemLeft" align="right" valign="top">VASurfaceID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVAProcPipelineParameterBuffer.html#a9a60820f23d4b34e4b9b3ef63c6e56d4">surface</a></td></tr>
<tr class="memdesc:a9a60820f23d4b34e4b9b3ef63c6e56d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Source surface ID.  <a href="#a9a60820f23d4b34e4b9b3ef63c6e56d4">More...</a><br /></td></tr>
<tr class="separator:a9a60820f23d4b34e4b9b3ef63c6e56d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a7be6853d73307e6209109bfd4bbf08"><td class="memItemLeft" align="right" valign="top">const VARectangle *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVAProcPipelineParameterBuffer.html#a2a7be6853d73307e6209109bfd4bbf08">surface_region</a></td></tr>
<tr class="memdesc:a2a7be6853d73307e6209109bfd4bbf08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Region within the source surface to be processed.  <a href="#a2a7be6853d73307e6209109bfd4bbf08">More...</a><br /></td></tr>
<tr class="separator:a2a7be6853d73307e6209109bfd4bbf08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28c546d07d38ae6f9b04c0fc12465f67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__api__vpp.html#ga7aa895516a4020fb9eb3fcb672429c6f">VAProcColorStandardType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVAProcPipelineParameterBuffer.html#a28c546d07d38ae6f9b04c0fc12465f67">surface_color_standard</a></td></tr>
<tr class="memdesc:a28c546d07d38ae6f9b04c0fc12465f67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requested input color primaries.  <a href="#a28c546d07d38ae6f9b04c0fc12465f67">More...</a><br /></td></tr>
<tr class="separator:a28c546d07d38ae6f9b04c0fc12465f67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b816fff16dc1cc4b49524866c9c25b0"><td class="memItemLeft" align="right" valign="top">const VARectangle *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVAProcPipelineParameterBuffer.html#a5b816fff16dc1cc4b49524866c9c25b0">output_region</a></td></tr>
<tr class="memdesc:a5b816fff16dc1cc4b49524866c9c25b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Region within the output surface.  <a href="#a5b816fff16dc1cc4b49524866c9c25b0">More...</a><br /></td></tr>
<tr class="separator:a5b816fff16dc1cc4b49524866c9c25b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92262881f575dbcbb6032569d4b02ba7"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVAProcPipelineParameterBuffer.html#a92262881f575dbcbb6032569d4b02ba7">output_background_color</a></td></tr>
<tr class="memdesc:a92262881f575dbcbb6032569d4b02ba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Background color.  <a href="#a92262881f575dbcbb6032569d4b02ba7">More...</a><br /></td></tr>
<tr class="separator:a92262881f575dbcbb6032569d4b02ba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac583d30bead8a2c05307a8fbfcf2ea9c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac583d30bead8a2c05307a8fbfcf2ea9c"></a>
<a class="el" href="group__api__vpp.html#ga7aa895516a4020fb9eb3fcb672429c6f">VAProcColorStandardType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVAProcPipelineParameterBuffer.html#ac583d30bead8a2c05307a8fbfcf2ea9c">output_color_standard</a></td></tr>
<tr class="memdesc:ac583d30bead8a2c05307a8fbfcf2ea9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requested output color primaries. <br /></td></tr>
<tr class="separator:ac583d30bead8a2c05307a8fbfcf2ea9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dc0b799d3248cb73c58493c7a0fa0f3"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVAProcPipelineParameterBuffer.html#a4dc0b799d3248cb73c58493c7a0fa0f3">pipeline_flags</a></td></tr>
<tr class="memdesc:a4dc0b799d3248cb73c58493c7a0fa0f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pipeline filters. See video pipeline flags.  <a href="#a4dc0b799d3248cb73c58493c7a0fa0f3">More...</a><br /></td></tr>
<tr class="separator:a4dc0b799d3248cb73c58493c7a0fa0f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb95e119ed7f841f71b2afbec2104784"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVAProcPipelineParameterBuffer.html#abb95e119ed7f841f71b2afbec2104784">filter_flags</a></td></tr>
<tr class="memdesc:abb95e119ed7f841f71b2afbec2104784"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extra filter flags. See vaPutSurface() flags.  <a href="#abb95e119ed7f841f71b2afbec2104784">More...</a><br /></td></tr>
<tr class="separator:abb95e119ed7f841f71b2afbec2104784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaeb764cace1d174d1e61afd37b01899"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__api__core.html#gad26441ddf2f4441ef65bbefa4662607f">VABufferID</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVAProcPipelineParameterBuffer.html#acaeb764cace1d174d1e61afd37b01899">filters</a></td></tr>
<tr class="memdesc:acaeb764cace1d174d1e61afd37b01899"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of filters to apply to the surface.  <a href="#acaeb764cace1d174d1e61afd37b01899">More...</a><br /></td></tr>
<tr class="separator:acaeb764cace1d174d1e61afd37b01899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dfcb4209d6dadcd6fec2cc7c4acc69f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2dfcb4209d6dadcd6fec2cc7c4acc69f"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVAProcPipelineParameterBuffer.html#a2dfcb4209d6dadcd6fec2cc7c4acc69f">num_filters</a></td></tr>
<tr class="memdesc:a2dfcb4209d6dadcd6fec2cc7c4acc69f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Actual number of filters. <br /></td></tr>
<tr class="separator:a2dfcb4209d6dadcd6fec2cc7c4acc69f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03619fd8a3eadc30bf824a0796805507"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a03619fd8a3eadc30bf824a0796805507"></a>
VASurfaceID *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVAProcPipelineParameterBuffer.html#a03619fd8a3eadc30bf824a0796805507">forward_references</a></td></tr>
<tr class="memdesc:a03619fd8a3eadc30bf824a0796805507"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of forward reference frames. <br /></td></tr>
<tr class="separator:a03619fd8a3eadc30bf824a0796805507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45c7c171928a33681db79288dc13be5d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a45c7c171928a33681db79288dc13be5d"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVAProcPipelineParameterBuffer.html#a45c7c171928a33681db79288dc13be5d">num_forward_references</a></td></tr>
<tr class="memdesc:a45c7c171928a33681db79288dc13be5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of forward reference frames that were supplied. <br /></td></tr>
<tr class="separator:a45c7c171928a33681db79288dc13be5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f0e379b748e72adeed6d30e8057f934"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2f0e379b748e72adeed6d30e8057f934"></a>
VASurfaceID *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVAProcPipelineParameterBuffer.html#a2f0e379b748e72adeed6d30e8057f934">backward_references</a></td></tr>
<tr class="memdesc:a2f0e379b748e72adeed6d30e8057f934"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of backward reference frames. <br /></td></tr>
<tr class="separator:a2f0e379b748e72adeed6d30e8057f934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adac7a536c5e058f9e87ec70a52ffe437"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adac7a536c5e058f9e87ec70a52ffe437"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVAProcPipelineParameterBuffer.html#adac7a536c5e058f9e87ec70a52ffe437">num_backward_references</a></td></tr>
<tr class="memdesc:adac7a536c5e058f9e87ec70a52ffe437"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of backward reference frames that were supplied. <br /></td></tr>
<tr class="separator:adac7a536c5e058f9e87ec70a52ffe437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8039510482a519325a4d3d29a8eddb1"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVAProcPipelineParameterBuffer.html#aa8039510482a519325a4d3d29a8eddb1">rotation_state</a></td></tr>
<tr class="memdesc:aa8039510482a519325a4d3d29a8eddb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotation state. See rotation angles.  <a href="#aa8039510482a519325a4d3d29a8eddb1">More...</a><br /></td></tr>
<tr class="separator:aa8039510482a519325a4d3d29a8eddb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae58f2a373e1638afc1673a55de28a04c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structVABlendState.html">VABlendState</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVAProcPipelineParameterBuffer.html#ae58f2a373e1638afc1673a55de28a04c">blend_state</a></td></tr>
<tr class="memdesc:ae58f2a373e1638afc1673a55de28a04c"><td class="mdescLeft">&#160;</td><td class="mdescRight">blending state. See "Video blending state definition".  <a href="#ae58f2a373e1638afc1673a55de28a04c">More...</a><br /></td></tr>
<tr class="separator:ae58f2a373e1638afc1673a55de28a04c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46ea097164b459fa1ee20bbb356a95c1"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVAProcPipelineParameterBuffer.html#a46ea097164b459fa1ee20bbb356a95c1">mirror_state</a></td></tr>
<tr class="separator:a46ea097164b459fa1ee20bbb356a95c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4d4141fba176fe2eb61bc22fb9dc215"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af4d4141fba176fe2eb61bc22fb9dc215"></a>
VASurfaceID *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVAProcPipelineParameterBuffer.html#af4d4141fba176fe2eb61bc22fb9dc215">additional_outputs</a></td></tr>
<tr class="memdesc:af4d4141fba176fe2eb61bc22fb9dc215"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of additional output surfaces. <br /></td></tr>
<tr class="separator:af4d4141fba176fe2eb61bc22fb9dc215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4293728d278cd608f3f8d6f9c4ae16e6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4293728d278cd608f3f8d6f9c4ae16e6"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVAProcPipelineParameterBuffer.html#a4293728d278cd608f3f8d6f9c4ae16e6">num_additional_outputs</a></td></tr>
<tr class="memdesc:a4293728d278cd608f3f8d6f9c4ae16e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of additional output surfaces. <br /></td></tr>
<tr class="separator:a4293728d278cd608f3f8d6f9c4ae16e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6117902e14ff685dc6799be15664bf9"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVAProcPipelineParameterBuffer.html#af6117902e14ff685dc6799be15664bf9">input_surface_flag</a></td></tr>
<tr class="memdesc:af6117902e14ff685dc6799be15664bf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag to indicate the input surface flag.  <a href="#af6117902e14ff685dc6799be15664bf9">More...</a><br /></td></tr>
<tr class="separator:af6117902e14ff685dc6799be15664bf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afed9e9553380dd5572e5a8753257e7e8"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVAProcPipelineParameterBuffer.html#afed9e9553380dd5572e5a8753257e7e8">output_surface_flag</a></td></tr>
<tr class="memdesc:afed9e9553380dd5572e5a8753257e7e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag to indicate the output surface flag.  <a href="#afed9e9553380dd5572e5a8753257e7e8">More...</a><br /></td></tr>
<tr class="separator:afed9e9553380dd5572e5a8753257e7e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26a1af96605d91d1e3479fc2f0232aa2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a26a1af96605d91d1e3479fc2f0232aa2"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVAProcPipelineParameterBuffer.html#a26a1af96605d91d1e3479fc2f0232aa2">va_reserved</a> [VA_PADDING_LARGE-11]</td></tr>
<tr class="memdesc:a26a1af96605d91d1e3479fc2f0232aa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserved bytes for future use, must be zero. <br /></td></tr>
<tr class="separator:a26a1af96605d91d1e3479fc2f0232aa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Video processing pipeline configuration. </p>
<p>This buffer defines a video processing pipeline. The actual filters to be applied are provided in the <code>filters</code> field, they can be re-used in other processing pipelines.</p>
<p>The target surface is specified by the <code>render_target</code> argument of <code><a class="el" href="group__api__core.html#gacf031b9aaf39365bf8d79d92372f2ec8">vaBeginPicture()</a></code>. The general usage model is described as follows:</p><ul>
<li><code><a class="el" href="group__api__core.html#gacf031b9aaf39365bf8d79d92372f2ec8">vaBeginPicture()</a></code>: specify the target surface that receives the processed output;</li>
<li><code><a class="el" href="group__api__core.html#ga3facc622a14fc901d5d44dcda845cb6f">vaRenderPicture()</a></code>: specify a surface to be processed and composed into the <code>render_target</code>. Use as many <code><a class="el" href="group__api__core.html#ga3facc622a14fc901d5d44dcda845cb6f">vaRenderPicture()</a></code> calls as necessary surfaces to compose ;</li>
<li><code><a class="el" href="group__api__core.html#gaffbd38af17b5f061707010287e7d4c97">vaEndPicture()</a></code>: tell the driver to start processing the surfaces with the requested filters.</li>
</ul>
<p>If a filter (e.g. noise reduction) needs to be applied with different values for multiple surfaces, the application needs to create as many filter parameter buffers as necessary. i.e. the filter parameters shall not change between two calls to <code><a class="el" href="group__api__core.html#ga3facc622a14fc901d5d44dcda845cb6f">vaRenderPicture()</a></code>.</p>
<p>For composition usage models, the first surface to process will generally use an opaque background color, i.e. <code>output_background_color</code> set with the most significant byte set to <code>0xff</code>. For instance, <code>0xff000000</code> for a black background. Then, subsequent surfaces would use a transparent background color. </p>
</div><h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="ae58f2a373e1638afc1673a55de28a04c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structVABlendState.html">VABlendState</a>* VAProcPipelineParameterBuffer::blend_state</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>blending state. See "Video blending state definition". </p>
<p>If <a class="el" href="structVAProcPipelineParameterBuffer.html#ae58f2a373e1638afc1673a55de28a04c">blend_state</a> is NULL, then default operation mode depends on the source <a class="el" href="structVAProcPipelineParameterBuffer.html#a9a60820f23d4b34e4b9b3ef63c6e56d4">surface</a> format:</p><ul>
<li>RGB: per-pixel alpha blending ;</li>
<li>YUV: no blending, i.e override the underlying pixels.</li>
</ul>
<p>Otherwise, <a class="el" href="structVAProcPipelineParameterBuffer.html#ae58f2a373e1638afc1673a55de28a04c">blend_state</a> is a pointer to a <a class="el" href="structVABlendState.html" title="Video blending state definition. ">VABlendState</a> structure that shall be live until <a class="el" href="group__api__core.html#gaffbd38af17b5f061707010287e7d4c97">vaEndPicture()</a>.</p>
<p>Implementation note: the driver is responsible for checking the blend state flags against the actual source <a class="el" href="structVAProcPipelineParameterBuffer.html#a9a60820f23d4b34e4b9b3ef63c6e56d4">surface</a> format. e.g. premultiplied alpha blending is only applicable to RGB surfaces, and luma keying is only applicable to YUV surfaces. If a mismatch occurs, then #VA_STATUS_ERROR_INVALID_BLEND_STATE is returned. </p>

</div>
</div>
<a class="anchor" id="abb95e119ed7f841f71b2afbec2104784"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t VAProcPipelineParameterBuffer::filter_flags</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extra filter flags. See vaPutSurface() flags. </p>
<p>Filter flags are used as a fast path, wherever possible, to use vaPutSurface() flags instead of explicit filter parameter buffers.</p>
<p>Allowed filter flags API-wise. Use <a class="el" href="group__api__vpp.html#gafcf3b8c6f75cfa2850ff9b9e3f0f339e" title="Queries video processing pipeline capabilities. ">vaQueryVideoProcPipelineCaps()</a> to check for implementation details:</p><ul>
<li>Bob-deinterlacing: <code>VA_FRAME_PICTURE</code>, <code>VA_TOP_FIELD</code>, <code>VA_BOTTOM_FIELD</code>. Note that any deinterlacing filter (<a class="el" href="group__api__vpp.html#gga3614dbee76b8ac89dd5a3dc8b1a12bb7ab7e7c1dd6966eda8c9fee5bb6e7fc88f" title="Deinterlacing filter. ">VAProcFilterDeinterlacing</a>) will override those flags.</li>
<li>Color space conversion: <code>VA_SRC_BT601</code>, <code>VA_SRC_BT709</code>, <code>VA_SRC_SMPTE_240</code>.</li>
<li>Scaling: <code>VA_FILTER_SCALING_DEFAULT</code>, <code>VA_FILTER_SCALING_FAST</code>, <code>VA_FILTER_SCALING_HQ</code>, <code>VA_FILTER_SCALING_NL_ANAMORPHIC</code>. </li>
</ul>

</div>
</div>
<a class="anchor" id="acaeb764cace1d174d1e61afd37b01899"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__api__core.html#gad26441ddf2f4441ef65bbefa4662607f">VABufferID</a>* VAProcPipelineParameterBuffer::filters</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Array of filters to apply to the surface. </p>
<p>The list of filters shall be ordered in the same way the driver expects them. i.e. as was returned from <a class="el" href="group__api__vpp.html#ga05286f03bec73c5d6354b4f097c49b3c" title="Queries video processing filters. ">vaQueryVideoProcFilters()</a>. Otherwise, a <a class="el" href="group__api__core.html#ga6398758c29fc5f4bd82631206b4de198" title="An invalid filter chain was supplied. ">VA_STATUS_ERROR_INVALID_FILTER_CHAIN</a> is returned from <a class="el" href="group__api__core.html#ga3facc622a14fc901d5d44dcda845cb6f">vaRenderPicture()</a> with this buffer.</p>
<p><a class="el" href="group__api__core.html#gacc4468b6c4055d0ec1475150ddd7fddb" title="An unsupported filter was supplied. ">VA_STATUS_ERROR_UNSUPPORTED_FILTER</a> is returned if the list contains an unsupported filter. </p>

</div>
</div>
<a class="anchor" id="af6117902e14ff685dc6799be15664bf9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t VAProcPipelineParameterBuffer::input_surface_flag</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flag to indicate the input surface flag. </p>
<p>bit0: 0 non-protected 1: protected bit 1~31 for future </p>

</div>
</div>
<a class="anchor" id="a46ea097164b459fa1ee20bbb356a95c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t VAProcPipelineParameterBuffer::mirror_state</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>mirroring state. See "Mirroring directions".</p>
<p>Mirroring of an image can be performed either along the horizontal or vertical axis. It is assumed that the rotation operation is always performed before the mirroring operation. </p>

</div>
</div>
<a class="anchor" id="a92262881f575dbcbb6032569d4b02ba7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t VAProcPipelineParameterBuffer::output_background_color</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Background color. </p>
<p>Background color used to fill in pixels that reside outside of the specified <a class="el" href="structVAProcPipelineParameterBuffer.html#a5b816fff16dc1cc4b49524866c9c25b0">output_region</a>. The color is specified in ARGB format: [31:24] alpha, [23:16] red, [15:8] green, [7:0] blue.</p>
<p>Unless the alpha value is zero or the <a class="el" href="structVAProcPipelineParameterBuffer.html#a5b816fff16dc1cc4b49524866c9c25b0">output_region</a> represents the whole target surface size, implementations shall not render the source surface to the target surface directly. Rather, in order to maintain the exact semantics of <a class="el" href="structVAProcPipelineParameterBuffer.html#a92262881f575dbcbb6032569d4b02ba7">output_background_color</a>, the driver shall use a temporary surface and fill it in with the appropriate background color. Next, the driver will blend this temporary surface into the target surface. </p>

</div>
</div>
<a class="anchor" id="a5b816fff16dc1cc4b49524866c9c25b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const VARectangle* VAProcPipelineParameterBuffer::output_region</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Region within the output surface. </p>
<p>Pointer to a #VARectangle defining the region within the output surface that receives the processed pixels. If NULL, <code>output_region</code> implies the whole surface.</p>
<p>Note that any pixels residing outside the specified region will be filled in with the <a class="el" href="structVAProcPipelineParameterBuffer.html#a92262881f575dbcbb6032569d4b02ba7">output_background_color</a>. </p>

</div>
</div>
<a class="anchor" id="afed9e9553380dd5572e5a8753257e7e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t VAProcPipelineParameterBuffer::output_surface_flag</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flag to indicate the output surface flag. </p>
<p>bit0: 0 non-protected 1: protected bit 1~31 for future </p>

</div>
</div>
<a class="anchor" id="a4dc0b799d3248cb73c58493c7a0fa0f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t VAProcPipelineParameterBuffer::pipeline_flags</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pipeline filters. See video pipeline flags. </p>
<p>Flags to control the pipeline, like whether to apply subpictures or not, notify the driver that it can opt for power optimizations, should this be needed. </p>

</div>
</div>
<a class="anchor" id="aa8039510482a519325a4d3d29a8eddb1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t VAProcPipelineParameterBuffer::rotation_state</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rotation state. See rotation angles. </p>
<p>The rotation angle is clockwise. There is no specific rotation center for this operation. Rather, The source <a class="el" href="structVAProcPipelineParameterBuffer.html#a9a60820f23d4b34e4b9b3ef63c6e56d4">surface</a> is first rotated by the specified angle and then scaled to fit the <a class="el" href="structVAProcPipelineParameterBuffer.html#a5b816fff16dc1cc4b49524866c9c25b0">output_region</a>.</p>
<p>This means that the top-left hand corner (0,0) of the output (rotated) surface is expressed as follows:</p><ul>
<li>VA_ROTATION_NONE: (0,0) is the top left corner of the source surface &ndash; no rotation is performed ;</li>
<li>VA_ROTATION_90: (0,0) is the bottom-left corner of the source surface ;</li>
<li>VA_ROTATION_180: (0,0) is the bottom-right corner of the source surface &ndash; the surface is flipped around the X axis ;</li>
<li>VA_ROTATION_270: (0,0) is the top-right corner of the source surface.</li>
</ul>
<p>Check <a class="el" href="structVAProcPipelineCaps.html#a6cc7462202955ac93b0e8c03f9c84f2e" title="Rotation flags. ">VAProcPipelineCaps::rotation_flags</a> first prior to defining a specific rotation angle. Otherwise, the hardware can perfectly ignore this variable if it does not support any rotation. </p>

</div>
</div>
<a class="anchor" id="a9a60820f23d4b34e4b9b3ef63c6e56d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VASurfaceID VAProcPipelineParameterBuffer::surface</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Source surface ID. </p>
<p>ID of the source surface to process. If subpictures are associated with the video surfaces then they shall be rendered to the target surface, if the <a class="el" href="group__api__vpp.html#ga99bb795d7d095a4c62537e807f2eb280" title="Specifies whether to apply subpictures when processing a surface. ">VA_PROC_PIPELINE_SUBPICTURES</a> pipeline flag is set. </p>

</div>
</div>
<a class="anchor" id="a28c546d07d38ae6f9b04c0fc12465f67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__api__vpp.html#ga7aa895516a4020fb9eb3fcb672429c6f">VAProcColorStandardType</a> VAProcPipelineParameterBuffer::surface_color_standard</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Requested input color primaries. </p>
<p>Color primaries are implicitly converted throughout the processing pipeline. The video processor chooses the best moment to apply this conversion. The set of supported color primaries primaries for input shall be queried with <a class="el" href="group__api__vpp.html#gafcf3b8c6f75cfa2850ff9b9e3f0f339e" title="Queries video processing pipeline capabilities. ">vaQueryVideoProcPipelineCaps()</a>. </p>

</div>
</div>
<a class="anchor" id="a2a7be6853d73307e6209109bfd4bbf08"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const VARectangle* VAProcPipelineParameterBuffer::surface_region</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Region within the source surface to be processed. </p>
<p>Pointer to a #VARectangle defining the region within the source surface to be processed. If NULL, <code>surface_region</code> implies the whole surface. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="va__vpp_8h_source.html">va_vpp.h</a></li>
</ul>
</div><!-- contents -->
<hr class="footer"/><address class="footer"><small>
Generated for VA-API by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11</small></address>
</body>
</html>
